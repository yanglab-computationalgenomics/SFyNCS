#!/usr/bin/env perl

# 2022-03-15

# 1. Function
# Add tophat supported statistics
# 1.1. if breakpoint is chr1:100:+ and --slop_length is 5, read aignned as <= chr1:105 by tophat will support breakpoint. If chr:1:100:-, read aligned as >=chr1:95 will support breakpoint
# 1.2. the distance between align position and breakpoint should be <= $window_size, should be same as --window_size in cluster_discordant_reads.pl
# 1.3. if both read 1 and read 2 are split reads, segment length in left and right breakpoint should be <= $length_threshold_if_both_mate_are_split_reads. Increase value for long reads
# 1.4. for read pair, the distance between read and breakpoint should be <= $window_size
# 1.5. drop junction type column

# 2. Input
# 2.1. tophat bam
# 2.2. filtered output which generated by identify_fusion_candidate_from_cluster_reads.pl
# column 1: chromosome of the left segment
# column 2: left segment breakpoint
# column 3: strand of the left segment
# column 4: chromosome of right segment
# column 5: right segment breakpoint
# column 6: strand of the right segment
# column 7: junction type: -1=read pair (between the mates), 1=split reads
# column 8: cluster id
# column 9: split read count
# column 10: read pair count
# column 11: split reads
# column 12: read pairs

# 3. Output
# column 1: chromosome of the left segment
# column 2: left segment breakpoint
# column 3: strand of the left segment
# column 4: chromosome of right segment
# column 5: right segment breakpoint
# column 6: strand of the right segment
# column 7: cluster id
# column 8: split read count (processed by tophat)
# column 9: read pair count (processed by tophat)
# column 10: minimum distance of read pair to left breakpoint 
# column 11: minimum distance of read pair to right breakpoint 
# column 12: split reads (processed by tophat)
# column 13: read pairs (processed by tophat)
# column 14: distance of read pair to left breakpoint
# column 15: distance of read pair to right breakpoint


use strict;
use 5.010;
use Getopt::Long;
use File::Basename;
use lib dirname $0;

my $slop_length=5;
my $length_threshold_if_both_mate_are_split_reads=200;
my $window_size=1000000;

GetOptions(
    's|slop_length=i'                                   => \$slop_length,
    'w|window_size=i'                                   => \$window_size,
    'l|length_threshold_if_both_mate_are_split_reads=i' =>  \$length_threshold_if_both_mate_are_split_reads,
    'h|help'    => sub{usage()}
)||usage();

my %hash;
open IN, "samtools view $ARGV[0] | " or die "Can't open $ARGV[0]:$!";
while(<IN>){
    chomp;
    my ($name, $flag, $chr, $start, $mapq, $ciga, $chr_mate, $start_mate, $tlen, $seq, $qual)=(split "\t",$_)[0..10];
    my $segment_index=&getReadIndex($flag);
    my $end=&getEnd($start, $ciga);
    my $temp_value=$chr.",".$start.",".$end;
    push @{$hash{$name}{$segment_index}}, $temp_value;
}
close(IN);

say join "\t", ("Chr_left", "Pos_left", "Strand_left", "Chr_right", "Pos_right", "Strand_right", "Cluster_id",
    "Split_read_count_(tophat)", "Read_pair_count_(tophat)",
    "Minimum_read_distance_to_left", "Minimum_read_distance_to_right",
    "Split_reads_(tophat)", "Read_pairs_(tophat)",
    "Read_pair_distance_to_left", "Read_pair_distance_to_right");
open IN, $ARGV[1] or die "Can't open $ARGV[1]:$!";
# input have header
<IN>;
while(<IN>){
    chomp;
    my ($chr_left, $pos_left, $strand_left, $chr_right, $pos_right, $strand_right, $junc_type, $cluster_id, $split_read_count, $read_pair_count, $split_reads, $read_pairs)=split "\t",$_;
    my ($split_reads_tophat, $read_pairs_tophat)=("NA") x 3;
    my ($split_read_count_tophat, $read_pair_count_tophat)=(0) x 3;
    my ($read_distance_to_left, $read_distance_to_right, $min_distance_left, $min_distance_right)=("NA") x 4;
    
    my @Split_reads=split ",", $split_reads;
    my @Read_pairs=split ",", $read_pairs;
    
    foreach my $read (@Split_reads){
        next if $read eq "NA";
        my (@tophat_read_1, @tophat_read_2);
        @tophat_read_1=@{$hash{$read}{"first"}} if exists $hash{$read}{"first"};
        @tophat_read_2=@{$hash{$read}{"second"}} if exists $hash{$read}{"second"};
        
        next if @tophat_read_1==0 || @tophat_read_2==0 || @tophat_read_1>2 || @tophat_read_2>2; # filter if one mate fail to align or align to more than two loci 
        next if @tophat_read_1==1 && @tophat_read_2==1; # read not report as split read by tophat
        
        my ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b); # a: left segment; b: right segment;
        if(@tophat_read_1==2 && @tophat_read_2==2){ # both read 1 and read 2 are split reads 
            $tophat_read_1[0]=~/(.*),(.*),(.*)/;
            my ($chr_1_a, $start_1_a, $end_1_a)=($1, $2, $3);
            $tophat_read_1[1]=~/(.*),(.*),(.*)/;
            my ($chr_1_b, $start_1_b, $end_1_b)=($1, $2, $3);
            $tophat_read_2[0]=~/(.*),(.*),(.*)/;
            my ($chr_2_a, $start_2_a, $end_2_a)=($1, $2, $3);
            $tophat_read_2[1]=~/(.*),(.*),(.*)/;
            my ($chr_2_b, $start_2_b, $end_2_b)=($1, $2, $3);
            my ($chr_1_left, $start_1_left, $end_1_left, $chr_1_right, $start_1_right, $end_1_right, $chr_2_left, $start_2_left, $end_2_left, $chr_2_right, $start_2_right, $end_2_right);
            if($chr_left eq $chr_right){
                next if $chr_1_a ne $chr_1_b || $chr_2_a ne $chr_2_b || $chr_1_a ne $chr_2_a || $chr_1_a ne $chr_left;
                
                if($end_1_a<$end_1_b){
                    ($chr_1_left, $start_1_left, $end_1_left, $chr_1_right, $start_1_right, $end_1_right)=($chr_1_a, $start_1_a, $end_1_a, $chr_1_b, $start_1_b, $end_1_b);
                }else{
                    ($chr_1_left, $start_1_left, $end_1_left, $chr_1_right, $start_1_right, $end_1_right)=($chr_1_b, $start_1_b, $end_1_b, $chr_1_a, $start_1_a, $end_1_a);
                }
                
                if($end_2_a<$end_2_b){
                    ($chr_2_left, $start_2_left, $end_2_left, $chr_2_right, $start_2_right, $end_2_right)=($chr_2_a, $start_2_a, $end_2_a, $chr_2_b, $start_2_b, $end_2_b);
                }else{
                    ($chr_2_left, $start_2_left, $end_2_left, $chr_2_right, $start_2_right, $end_2_right)=($chr_2_b, $start_2_b, $end_2_b, $chr_2_a, $start_2_a, $end_2_a);
                }
            }else{
                if($chr_1_a eq $chr_left){
                    ($chr_1_left, $start_1_left, $end_1_left, $chr_1_right, $start_1_right, $end_1_right)=($chr_1_a, $start_1_a, $end_1_a, $chr_1_b, $start_1_b, $end_1_b);
                }else{
                    ($chr_1_left, $start_1_left, $end_1_left, $chr_1_right, $start_1_right, $end_1_right)=($chr_1_b, $start_1_b, $end_1_b, $chr_1_a, $start_1_a, $end_1_a);
                }
                next if $chr_1_left ne $chr_left || $chr_1_right ne $chr_right;
                
                if($chr_2_a eq $chr_left){
                    ($chr_2_left, $start_2_left, $end_2_left, $chr_2_right, $start_2_right, $end_2_right)=($chr_2_a, $start_2_a, $end_2_a, $chr_2_b, $start_2_b, $end_2_b);
                }else{
                    ($chr_2_left, $start_2_left, $end_2_left, $chr_2_right, $start_2_right, $end_2_right)=($chr_2_b, $start_2_b, $end_2_b, $chr_2_a, $start_2_a, $end_2_a);
                }
                next if $chr_2_left ne $chr_left || $chr_2_right ne $chr_right;
            }
            ($chr_a, $chr_b)=($chr_left, $chr_right);
            $start_a=($start_1_left<$start_2_left) ? $start_1_left : $start_2_left;
            $end_a=($end_1_left<$end_2_left) ? $end_2_left : $end_1_left;
            next if $end_a-$start_a>$length_threshold_if_both_mate_are_split_reads; # $length_threshold_if_both_mate_are_split_reads is artifact number (200), if both reads are split reads, one segment should not longer than read length
            $start_b=($start_1_right<$start_2_right) ? $start_1_right : $start_2_right;
            $end_b=($end_1_right<$end_2_right) ? $end_2_right : $end_1_right;
            next if $end_b-$start_b>$length_threshold_if_both_mate_are_split_reads; # $length_threshold_if_both_mate_are_split_reads is artifact number (200), if both reads are split reads, one segment should not longer than read length
        }else{ # (@tophat_read_1==1 && @tophat_read_2==2) || (@tophat_read_1==2 && @tophat_read_2==1)
            my ($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2, $chr_mate, $start_mate, $end_mate);
            my ($chr_split_left, $start_split_left, $end_split_left, $chr_split_right, $start_split_right, $end_split_right);
            if(@tophat_read_1==1){
                $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                ($chr_split_1, $start_split_1, $end_split_1)=($1, $2, $3);
                $tophat_read_2[1]=~/(.*),(.*),(.*)/;
                ($chr_split_2, $start_split_2, $end_split_2)=($1, $2, $3);
                $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                ($chr_mate, $start_mate, $end_mate)=($1, $2, $3);
            }else{
                $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                ($chr_split_1, $start_split_1, $end_split_1)=($1, $2, $3);
                $tophat_read_1[1]=~/(.*),(.*),(.*)/;
                ($chr_split_2, $start_split_2, $end_split_2)=($1, $2, $3);
                $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                ($chr_mate, $start_mate, $end_mate)=($1, $2, $3);
            }
            
            if($chr_left eq $chr_right){
                next if $chr_split_1 ne $chr_split_2 || $chr_split_1 ne $chr_mate || $chr_split_1 ne $chr_left;
                if($start_split_1<$start_split_2){
                    ($chr_split_left, $start_split_left, $end_split_left, $chr_split_right, $start_split_right, $end_split_right)=($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2);
                }else{
                    ($chr_split_left, $start_split_left, $end_split_left, $chr_split_right, $start_split_right, $end_split_right)=($chr_split_2, $start_split_2, $end_split_2, $chr_split_1, $start_split_1, $end_split_1);
                }
                    
                my $distance_mate_to_split_left=abs($start_mate-$start_split_left);
                my $distance_mate_to_split_right=abs($start_mate-$start_split_right);
                ($chr_a, $chr_b)=($chr_left, $chr_right);
                if($distance_mate_to_split_left<$distance_mate_to_split_right){
                    $start_a=($start_split_left<$start_mate) ? $start_split_left : $start_mate;
                    $end_a=($end_split_left<$end_mate) ? $end_mate : $end_split_left;
                    ($start_b, $end_b)=($start_split_right, $end_split_right);
                }else{
                    ($start_a, $end_a)=($start_split_left, $end_split_left);
                    $start_b=($start_split_right<$start_mate) ? $start_split_right : $start_mate;
                    $end_b=($end_split_right<$end_mate) ? $end_mate : $end_split_right;
                }
            }else{
                next if $chr_left ne $chr_mate && $chr_right ne $chr_mate;
                
                if($chr_split_1 eq $chr_left){
                    ($chr_split_left, $start_split_left, $end_split_left, $chr_split_right, $start_split_right, $end_split_right)=($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2);
                }else{
                    ($chr_split_left, $start_split_left, $end_split_left, $chr_split_right, $start_split_right, $end_split_right)=($chr_split_2, $start_split_2, $end_split_2, $chr_split_1, $start_split_1, $end_split_1);
                }
                next if $chr_split_left ne $chr_left || $chr_split_right ne $chr_right;
                
                ($chr_a, $chr_b)=($chr_left, $chr_right);
                if($chr_left eq $chr_mate){
                    $start_a=($start_split_left<$start_mate) ? $start_split_left : $start_mate;
                    $end_a=($end_split_left<$end_mate) ? $end_mate : $end_split_left;
                    ($start_b, $end_b)=($start_split_right, $end_split_right);
                }else{
                    ($start_a, $end_a)=($start_split_left, $end_split_left);
                    $start_b=($start_split_right<$start_mate) ? $start_split_right : $start_mate;
                    $end_b=($end_split_right<$end_mate) ? $end_mate : $end_split_right;
                }
            }
            
        }
        
        # compare read to breakpoints
        my ($is_left_support_breakpoint, $is_right_support_breakpoint)=(0) x 2;
        $is_left_support_breakpoint=&compareSplitReadToBreakpoint($pos_left, $strand_left, $start_a, $end_a);
        $is_right_support_breakpoint=&compareSplitReadToBreakpoint($pos_right, $strand_right, $start_b, $end_b);
        
        if($is_left_support_breakpoint==1 && $is_right_support_breakpoint==1){
            $split_read_count_tophat++;
            $split_reads_tophat.=",".$read;
        }
    }
    
    foreach my $read (@Read_pairs){
        next if $read eq "NA";
        my (@tophat_read_1, @tophat_read_2);
        @tophat_read_1=@{$hash{$read}{"first"}} if exists $hash{$read}{"first"};
        @tophat_read_2=@{$hash{$read}{"second"}} if exists $hash{$read}{"second"};
        
        next if @tophat_read_1!=1 || @tophat_read_2!=1; # not unique aligned
        my ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b); # a: left segment; b: right segment;
        $tophat_read_1[0]=~/(.*),(.*),(.*)/;
        my ($chr_1, $start_1, $end_1)=($1, $2, $3);
        $tophat_read_2[0]=~/(.*),(.*),(.*)/;
        my ($chr_2, $start_2, $end_2)=($1, $2, $3);
        if($chr_left eq $chr_right){
            next if $chr_1 ne $chr_2;
            next if $chr_1 ne $chr_left;
            
            if($end_1<$end_2){
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
            }else{
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1);
            }
        }else{
            if($chr_1 eq $chr_left){
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
            }else{
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1);
            }
            next if $chr_a ne $chr_left || $chr_b ne $chr_right;
        }
        
        # compare read to breakpoints
        my ($is_left_support_breakpoint, $is_right_support_breakpoint)=(0) x 2;
        my ($temp_distance_left, $temp_distance_right)=(0) x 2;
        if($strand_left eq '+'){
            $is_left_support_breakpoint=1 if ($end_a<=$pos_left) && ($pos_left-$end_a<=$window_size);
            $temp_distance_left=$pos_left-$end_a;
        }else{
            $is_left_support_breakpoint=1 if ($start_a>=$pos_left) && ($start_a-$pos_left<=$window_size);
            $temp_distance_left=$start_a-$pos_left;
        }
        if($strand_right eq '+'){
            $is_right_support_breakpoint=1 if ($end_b<=$pos_right) && ($pos_right-$end_b<=$window_size);
            $temp_distance_right=$pos_right-$end_b;
        }else{
            $is_right_support_breakpoint=1 if ($start_b>=$pos_right) && ($start_b-$pos_right<=$window_size);
            $temp_distance_right=$start_b-$pos_right;
        }
        
        if($is_left_support_breakpoint==1 && $is_right_support_breakpoint==1){
            $read_pair_count_tophat++;
            $read_pairs_tophat.=",".$read;
            
            $read_distance_to_left.=",".$temp_distance_left;
            $read_distance_to_right.=",".$temp_distance_right;
            if($min_distance_left eq "NA"){
                $min_distance_left=$temp_distance_left;
            }elsif($min_distance_left>$temp_distance_left){
                $min_distance_left=$temp_distance_left;
            }
            if($min_distance_right eq "NA"){
                $min_distance_right=$temp_distance_right;
            }elsif($min_distance_right>$temp_distance_right){
                $min_distance_right=$temp_distance_right;
            }
        }
    }
        
    $split_reads_tophat=~s/NA,//;
    $read_pairs_tophat=~s/NA,//;
    $read_distance_to_left=~s/NA,//;
    $read_distance_to_right=~s/NA,//;
    say join "\t", ($chr_left, $pos_left, $strand_left, $chr_right, $pos_right, $strand_right, $cluster_id,
        $split_read_count_tophat, $read_pair_count_tophat,
        $min_distance_left, $min_distance_right,
        $split_reads_tophat, $read_pairs_tophat,
        $read_distance_to_left, $read_distance_to_right);
}
close(IN);

sub getReadIndex{
    my ($flag)=@_;
    my $segment_index;
    if($flag & 64){
        $segment_index="first";
    }else{
        $segment_index="second";
    }
    return $segment_index;
}

sub getEnd{
    my ($start, $cigar)=@_;
    my $end=$start-1; # start is 1-base, change to 0-base
    while($cigar =~ /(\d+)([A-Zp])/g) {
        my $len = $1;
        my $code = $2;
        unless($code =~ /^[MSDNIHp]$/) {
            say STDERR "Error, cannot parse cigar code [$code] ";
        }
        $end+=$len if $code eq "M" || $code eq "N" || $code eq "D";
    }
    return $end;
}

sub compareSplitReadToBreakpoint{
    my ($pos_breakpoint, $strand_breakpoint, $start_read, $end_read)=@_;
    my $is_support_breakpoint=0;
    if($strand_breakpoint eq '+'){
        $is_support_breakpoint=1 if ($end_read<=$pos_breakpoint+$slop_length) && ($pos_breakpoint+$slop_length-$end_read<=$window_size);
    }else{
        $is_support_breakpoint=1 if ($start_read>=$pos_breakpoint-$slop_length) && ($start_read-$pos_breakpoint+$slop_length<=$window_size);
    }
    return $is_support_breakpoint;
}

sub usage{
    my $scriptName = basename $0;
print <<HELP;
This script was used to get tophat supported statistics
Usage: perl $scriptName tophat.bam input >output
Options:

    -s --slop_length	                                read align within this range of breakpoint will support the breakpoint [default: $slop_length]
    -w --window_size	                                to support breakpoint, the distance between read pair and breakpoint should be <= this value [default: $window_size]
    -l --length_threshold_if_both_mate_are_split_reads	segment length in left and right breakpoint should be <= this value if both read 1 and read 2 are split reads [default: $length_threshold_if_both_mate_are_split_reads]
    -h --help     	                                print this help information
HELP
    exit(-1);
}