#!/usr/bin/env perl

# 2022-11-04

# 1. Function
# Add tophat supported statistics
# 1.1. if breakpoint is chr1:100:+ and --overhang_length is 5, read aignned as <= chr1:105 by tophat will support breakpoint. If chr:1:100:-, read aligned as >=chr1:95 will support breakpoint
# 1.2. the distance between align position and breakpoint should be <= $window_size, should be same as --window_size in cluster_discordant_reads.pl
# 1.3. if both read 1 and read 2 are split reads, segment length in left and right breakpoint should be <= $length_threshold_if_both_mate_are_split_reads. Increase value for long reads
# 1.4. for read pair, the distance between read and breakpoint should be <= $window_size
# 1.5. drop junction type column

# 2. Input
# 2.1. tophat bam
# 2.2. filtered output which generated by identify_fusion_candidate_from_cluster_reads.pl
# column 1: chromosome of breakpoint 1
# column 2: breakpoint 1 position (1-based)
# column 3: breakpoint 1 strand (different from input strand, + means left of the site will be used, while - means right of site will be used)
# column 4: chromosome of breakpoint 2
# column 5: breakpoint 2 position (1-based)
# column 6: breakpoint 2 strand (different from input strand, + means left of the site will be used, while - means right of site will be used)
# column 7: junction type: -1=encompassing junction (between the mates), 1=split reads
# column 8: cluster id
# column 9: split read count reported by STAR (e.g., 1)
# column 10: read pair count reported by STAR (e.g., 4)
# column 11: split reads reported by STAR (e.g., read_23)
# column 12: read pairs reported by STAR (e.g., read_38,read_62,read_70,read_8)

# 3. Output
# column 1: chromosome of breakpoint 1
# column 2: breakpoint 1 position (1-based)
# column 3: breakpoint 1 strand 
# column 4: chromosome of breakpoint 2
# column 5: breakpoint 2 position (1-based)
# column 6: breakpoint 2 strand
# column 7: cluster id
# column 8: split read count reported by STAR (e.g., 1)
# column 9: read pair count reported by STAR (e.g., 4)
# column 10: split read count supported by TopHat (e.g., 1)
# column 11: potential split read count not supported by TopHat (e.g., 0)
# column 12: read pair count reported by TopHat 
# column 13: minimal distance between read pair and breakpoint 1 after aligning by TopHat (e.g., 13)
# column 14: minimal distance between read pair and breakpoint 2 after aligning by TopHat (e.g., 22)
# column 15: split reads reported by STAR (e.g., read_23)
# column 16: read pairs reported by STAR (e.g., read_38,read_62,read_70,read_8)
# column 17: split reads supported by TopHat (e.g., read_23)
# column 18: potential split reads not supported by TopHat (e.g., NA)
# column 19: read pairs supported by TopHat (e.g., read_38,read_70,read_8)
# column 20: distance between each read pair and breakpoint 1 after aligning by TopHat (e.g., 740,23,13)
# column 21: distance between each read pair and breakpoint 2 after aligning by TopHat (e.g., 292,2592,22)


use strict;
use 5.010;
use Getopt::Long;
use File::Basename;
use lib dirname $0;

my $overhang_length=5;
my $length_threshold_if_both_mate_are_split_reads=200;
my $window_size=1000000;
my $max_read_pair_distance=10000;
my $min_split_reads=1;
my $min_read_pairs=1;
my $min_total_reads=3;

GetOptions(
    'o|overhang_length=i'                               =>   \$overhang_length,
    'w|window_size=i'                                   =>   \$window_size,
    'l|length_threshold_if_both_mate_are_split_reads=i' =>   \$length_threshold_if_both_mate_are_split_reads,
    'd|max_read_pair_distance=i'                        =>   \$max_read_pair_distance,
    'p|min_split_reads=i'                               =>   \$min_split_reads,
    'r|min_read_pairs=i'                                =>   \$min_read_pairs,
    't|min_total_reads=i'                               =>   \$min_total_reads,
    'h|help'    => sub{usage()}
)||usage();

my %hash;
open IN, "samtools view $ARGV[0] | " or die "Can't open $ARGV[0]:$!";
while(<IN>){
    chomp;
    my ($name, $flag, $chr, $start, $mapq, $ciga, $chr_mate, $start_mate, $tlen, $seq, $qual)=(split "\t",$_)[0..10];
    my $segment_index=&getReadIndex($flag);
    my $end=&getEnd($start, $ciga);
    my $temp_value=$chr.",".$start.",".$end;
    push @{$hash{$name}{$segment_index}}, $temp_value;
}
close(IN);

say join "\t", ("Chr_breakpoint_1", "Pos_breakpoint_1", "Strand_breakpoint_1", "Chr_breakpoint_2", "Pos_breakpoint_2", "Strand_breakpoint_2", "Cluster_id",
    "Split_read_count_(star)", "Read_pair_count_(star)", "Split_read_count_(tophat)", "Potential_split_read_count_(tophat)", "Read_pair_count_(tophat)",
    "Minimum_read_pair_distance_to_breakpoint_1", "Minimum_read_pair_distance_to_breakpoint_2",
    "Split_reads_(star)", "Read_pairs_(star)", "Split_reads_(tophat)", "Potential_split_reads_(tophat)", "Read_pairs_(tophat)",
    "Read_pair_distance_to_breakpoint_1", "Read_pair_distance_to_breakpoint_2");
open IN, $ARGV[1] or die "Can't open $ARGV[1]:$!";
# input have header
<IN>;
while(<IN>){
    chomp;
    my ($chr_breakpoint_1, $pos_breakpoint_1, $strand_breakpoint_1, $chr_breakpoint_2, $pos_breakpoint_2, $strand_breakpoint_2, $junc_type, $cluster_id, $split_read_count, $read_pair_count, $split_reads, $read_pairs)=split "\t",$_;
    my ($split_reads_tophat, $read_pairs_tophat)=("NA") x 3;
    my ($split_read_count_tophat, $read_pair_count_tophat)=(0) x 3;
    my ($potential_split_read_count_tophat, $potential_split_reads_tophat)=(0, "NA"); # delete this if potential read is not needed
    my ($read_distance_to_breakpoint_1, $read_distance_to_breakpoint_2, $min_read_pair_distance_breakpoint_1, $min_read_pair_distance_breakpoint_2)=("NA") x 4;
    
    my @Split_reads=split ",", $split_reads;
    my @Read_pairs=split ",", $read_pairs;

    if(0>1){ # this backup code didn't include potential_split_reads_tophat
        foreach my $read (@Split_reads){
            next if $read eq "NA";
            my (@tophat_read_1, @tophat_read_2);
            @tophat_read_1=@{$hash{$read}{"first"}} if exists $hash{$read}{"first"};
            @tophat_read_2=@{$hash{$read}{"second"}} if exists $hash{$read}{"second"};
            
            
            next if @tophat_read_1==0 || @tophat_read_2==0 || @tophat_read_1>2 || @tophat_read_2>2; # filter if one mate fail to align or align to more than two loci 
            next if @tophat_read_1==1 && @tophat_read_2==1; # read not report as split read by tophat
            
            my ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b); # a: left segment; b: right segment;
            if(@tophat_read_1==2 && @tophat_read_2==2){ # both read 1 and read 2 are split reads 
                $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                my ($chr_1_a, $start_1_a, $end_1_a)=($1, $2, $3);
                $tophat_read_1[1]=~/(.*),(.*),(.*)/;
                my ($chr_1_b, $start_1_b, $end_1_b)=($1, $2, $3);
                $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                my ($chr_2_a, $start_2_a, $end_2_a)=($1, $2, $3);
                $tophat_read_2[1]=~/(.*),(.*),(.*)/;
                my ($chr_2_b, $start_2_b, $end_2_b)=($1, $2, $3);
                my ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2, $chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2);
                if($chr_breakpoint_1 eq $chr_breakpoint_2){
                    next if $chr_1_a ne $chr_1_b || $chr_2_a ne $chr_2_b || $chr_1_a ne $chr_2_a || $chr_1_a ne $chr_breakpoint_1;
                    
                    if($end_1_a<$end_1_b){
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_a, $start_1_a, $end_1_a, $chr_1_b, $start_1_b, $end_1_b);
                    }else{
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_b, $start_1_b, $end_1_b, $chr_1_a, $start_1_a, $end_1_a);
                    }
                    
                    if($end_2_a<$end_2_b){
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_a, $start_2_a, $end_2_a, $chr_2_b, $start_2_b, $end_2_b);
                    }else{
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_b, $start_2_b, $end_2_b, $chr_2_a, $start_2_a, $end_2_a);
                    }
                }else{
                    if($chr_1_a eq $chr_breakpoint_1){
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_a, $start_1_a, $end_1_a, $chr_1_b, $start_1_b, $end_1_b);
                    }else{
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_b, $start_1_b, $end_1_b, $chr_1_a, $start_1_a, $end_1_a);
                    }
                    next if $chr_1_breakpoint_1 ne $chr_breakpoint_1 || $chr_1_breakpoint_2 ne $chr_breakpoint_2;
                    
                    if($chr_2_a eq $chr_breakpoint_1){
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_a, $start_2_a, $end_2_a, $chr_2_b, $start_2_b, $end_2_b);
                    }else{
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_b, $start_2_b, $end_2_b, $chr_2_a, $start_2_a, $end_2_a);
                    }
                    next if $chr_2_breakpoint_1 ne $chr_breakpoint_1 || $chr_2_breakpoint_2 ne $chr_breakpoint_2;
                }
                ($chr_a, $chr_b)=($chr_breakpoint_1, $chr_breakpoint_2);
                $start_a=($start_1_breakpoint_1<$start_2_breakpoint_1) ? $start_1_breakpoint_1 : $start_2_breakpoint_1;
                $end_a=($end_1_breakpoint_1<$end_2_breakpoint_1) ? $end_2_breakpoint_1 : $end_1_breakpoint_1;
                next if $end_a-$start_a>$length_threshold_if_both_mate_are_split_reads; # $length_threshold_if_both_mate_are_split_reads is artifact number (200), if both reads are split reads, one segment should not longer than read length
                $start_b=($start_1_breakpoint_2<$start_2_breakpoint_2) ? $start_1_breakpoint_2 : $start_2_breakpoint_2;
                $end_b=($end_1_breakpoint_2<$end_2_breakpoint_2) ? $end_2_breakpoint_2 : $end_1_breakpoint_2;
                next if $end_b-$start_b>$length_threshold_if_both_mate_are_split_reads; # $length_threshold_if_both_mate_are_split_reads is artifact number (200), if both reads are split reads, one segment should not longer than read length
            }else{ # (@tophat_read_1==1 && @tophat_read_2==2) || (@tophat_read_1==2 && @tophat_read_2==1)
                my ($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2, $chr_mate, $start_mate, $end_mate);
                my ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2);
                if(@tophat_read_1==1){
                    $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                    ($chr_split_1, $start_split_1, $end_split_1)=($1, $2, $3);
                    $tophat_read_2[1]=~/(.*),(.*),(.*)/;
                    ($chr_split_2, $start_split_2, $end_split_2)=($1, $2, $3);
                    $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                    ($chr_mate, $start_mate, $end_mate)=($1, $2, $3);
                }else{
                    $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                    ($chr_split_1, $start_split_1, $end_split_1)=($1, $2, $3);
                    $tophat_read_1[1]=~/(.*),(.*),(.*)/;
                    ($chr_split_2, $start_split_2, $end_split_2)=($1, $2, $3);
                    $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                    ($chr_mate, $start_mate, $end_mate)=($1, $2, $3);
                }
                
                if($chr_breakpoint_1 eq $chr_breakpoint_2){
                    next if $chr_split_1 ne $chr_split_2 || $chr_split_1 ne $chr_mate || $chr_split_1 ne $chr_breakpoint_1;
                    if($start_split_1<$start_split_2){
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2);
                    }else{
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_2, $start_split_2, $end_split_2, $chr_split_1, $start_split_1, $end_split_1);
                    }
                        
                    my $distance_mate_to_split_breakpoint_1=abs($start_mate-$start_split_breakpoint_1);
                    my $distance_mate_to_split_breakpoint_2=abs($start_mate-$start_split_breakpoint_2);
                    ($chr_a, $chr_b)=($chr_breakpoint_1, $chr_breakpoint_2);
                    if($distance_mate_to_split_breakpoint_1<$distance_mate_to_split_breakpoint_2){
                        $start_a=($start_split_breakpoint_1<$start_mate) ? $start_split_breakpoint_1 : $start_mate;
                        $end_a=($end_split_breakpoint_1<$end_mate) ? $end_mate : $end_split_breakpoint_1;
                        ($start_b, $end_b)=($start_split_breakpoint_2, $end_split_breakpoint_2);
                    }else{
                        ($start_a, $end_a)=($start_split_breakpoint_1, $end_split_breakpoint_1);
                        $start_b=($start_split_breakpoint_2<$start_mate) ? $start_split_breakpoint_2 : $start_mate;
                        $end_b=($end_split_breakpoint_2<$end_mate) ? $end_mate : $end_split_breakpoint_2;
                    }
                }else{
                    next if $chr_breakpoint_1 ne $chr_mate && $chr_breakpoint_2 ne $chr_mate;
                    
                    if($chr_split_1 eq $chr_breakpoint_1){
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2);
                    }else{
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_2, $start_split_2, $end_split_2, $chr_split_1, $start_split_1, $end_split_1);
                    }
                    next if $chr_split_breakpoint_1 ne $chr_breakpoint_1 || $chr_split_breakpoint_2 ne $chr_breakpoint_2;
                    
                    ($chr_a, $chr_b)=($chr_breakpoint_1, $chr_breakpoint_2);
                    if($chr_breakpoint_1 eq $chr_mate){
                        $start_a=($start_split_breakpoint_1<$start_mate) ? $start_split_breakpoint_1 : $start_mate;
                        $end_a=($end_split_breakpoint_1<$end_mate) ? $end_mate : $end_split_breakpoint_1;
                        ($start_b, $end_b)=($start_split_breakpoint_2, $end_split_breakpoint_2);
                    }else{
                        ($start_a, $end_a)=($start_split_breakpoint_1, $end_split_breakpoint_1);
                        $start_b=($start_split_breakpoint_2<$start_mate) ? $start_split_breakpoint_2 : $start_mate;
                        $end_b=($end_split_breakpoint_2<$end_mate) ? $end_mate : $end_split_breakpoint_2;
                    }
                }
                
            }
            
            # compare read to breakpoints
            my ($is_breakpoint_1_support_breakpoint, $is_breakpoint_2_support_breakpoint)=(0) x 2;
            $is_breakpoint_1_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_1, $strand_breakpoint_1, $start_a, $end_a);
            $is_breakpoint_2_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_2, $strand_breakpoint_2, $start_b, $end_b);
            
            if($is_breakpoint_1_support_breakpoint==1 && $is_breakpoint_2_support_breakpoint==1){
                $split_read_count_tophat++;
                $split_reads_tophat.=",".$read;
            }
        }
    }
    
    foreach my $read (@Split_reads){
        next if $read eq "NA";
        #my @tophat_read_1=sort keys %{$hash{$read}{"first"}} if exists $hash{$read}{"first"};
        #my @tophat_read_2=sort keys %{$hash{$read}{"second"}} if exists $hash{$read}{"second"};
        my (@tophat_read_1, @tophat_read_2);
        @tophat_read_1=@{$hash{$read}{"first"}} if exists $hash{$read}{"first"};
        @tophat_read_2=@{$hash{$read}{"second"}} if exists $hash{$read}{"second"};
        
        # filter if one mate fail to align or align to more than two loci 
        next if @tophat_read_1>2 || @tophat_read_2>2;
        if(@tophat_read_1==0 || @tophat_read_2==0){ # may the problem of tophat
            my @tophat_align=(@tophat_read_1==0) ? @tophat_read_2 : @tophat_read_1;
            if(@tophat_align==1){ # may split read
                $tophat_align[0]=~/(.*),(.*),(.*)/;
                my ($chr_read, $start_read, $end_read)=($1, $2, $3);
                # compare read to breakpoints
                my ($is_breakpoint_1_support_breakpoint, $is_breakpoint_2_support_breakpoint)=(0) x 2;
                $is_breakpoint_1_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_1, $strand_breakpoint_1, $start_read, $end_read);
                $is_breakpoint_2_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_2, $strand_breakpoint_2, $start_read, $end_read);
                
                if($is_breakpoint_1_support_breakpoint==1 || $is_breakpoint_2_support_breakpoint==1){
                    $potential_split_read_count_tophat++;
                    $potential_split_reads_tophat.=",".$read;
                }
            }else{ # split read
                my ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read);
                $tophat_align[0]=~/(.*),(.*),(.*)/;
                my ($chr_1, $start_1, $end_1)=($1, $2, $3);
                $tophat_align[1]=~/(.*),(.*),(.*)/;
                my ($chr_2, $start_2, $end_2)=($1, $2, $3);
                
                if($chr_breakpoint_1 eq $chr_breakpoint_2){
                    next if $chr_1 ne $chr_2 || $chr_1 ne $chr_breakpoint_1;
                    ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
                    ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=
                        ($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1) if $end_2 < $end_1 || ($end_2==$end_1 && $start_2<$start_1);
                }else{
                    if($chr_breakpoint_1_read eq $chr_breakpoint_1){
                        ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
                    }else{
                        ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1)
                    }
                    next if $chr_breakpoint_1_read ne $chr_breakpoint_1 || $chr_breakpoint_2_read ne $chr_breakpoint_2;
                }
                
                # compare read to breakpoints
                my ($is_breakpoint_1_support_breakpoint, $is_breakpoint_2_support_breakpoint)=(0) x 2;
                $is_breakpoint_1_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_1, $strand_breakpoint_1, $start_breakpoint_1_read, $end_breakpoint_1_read);
                $is_breakpoint_2_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_2, $strand_breakpoint_2, $start_breakpoint_2_read, $end_breakpoint_2_read);
                
                if($is_breakpoint_1_support_breakpoint==1 && $is_breakpoint_2_support_breakpoint==1){ # use && as it is split read, in contrast, in @tophat_read_1==1 && @tophat_read_2==1 below, use || since the read may come from left segment or right segment
                    $potential_split_read_count_tophat++;
                    $potential_split_reads_tophat.=",".$read;
                }
            }
        }elsif(@tophat_read_1==1 && @tophat_read_2==1){ # read not report as split read by tophat, may the problem of tophat
            my ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read);
            $tophat_read_1[0]=~/(.*),(.*),(.*)/;
            my ($chr_1, $start_1, $end_1)=($1, $2, $3);
            $tophat_read_2[0]=~/(.*),(.*),(.*)/;
            my ($chr_2, $start_2, $end_2)=($1, $2, $3);
            
            if($chr_breakpoint_1 eq $chr_breakpoint_2){
                next if $chr_1 ne $chr_2 || $chr_1 ne $chr_breakpoint_1;
                ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
                ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=
                    ($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1) if $end_2 < $end_1 || ($end_2==$end_1 && $start_2<$start_1);
            }else{
                if($chr_breakpoint_1_read eq $chr_breakpoint_1){
                    ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
                }else{
                    ($chr_breakpoint_1_read, $start_breakpoint_1_read, $end_breakpoint_1_read, $chr_breakpoint_2_read, $start_breakpoint_2_read, $end_breakpoint_2_read)=($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1)
                }
                next if $chr_breakpoint_1_read ne $chr_breakpoint_1 || $chr_breakpoint_2_read ne $chr_breakpoint_2;
            }
            
            # compare read to breakpoints
            my ($is_breakpoint_1_support_breakpoint, $is_breakpoint_2_support_breakpoint)=(0) x 2;
            $is_breakpoint_1_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_1, $strand_breakpoint_1, $start_breakpoint_1_read, $end_breakpoint_1_read);
            $is_breakpoint_2_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_2, $strand_breakpoint_2, $start_breakpoint_2_read, $end_breakpoint_2_read);
            
            if($is_breakpoint_1_support_breakpoint==1 || $is_breakpoint_2_support_breakpoint==1){
                $potential_split_read_count_tophat++;
                $potential_split_reads_tophat.=",".$read;
            }
        }else{ # read report as split read by tophat
            my ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b); # a: left segment; b: right segment;
            if(@tophat_read_1==2 && @tophat_read_2==2){
                $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                my ($chr_1_a, $start_1_a, $end_1_a)=($1, $2, $3);
                $tophat_read_1[1]=~/(.*),(.*),(.*)/;
                my ($chr_1_b, $start_1_b, $end_1_b)=($1, $2, $3);
                $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                my ($chr_2_a, $start_2_a, $end_2_a)=($1, $2, $3);
                $tophat_read_2[1]=~/(.*),(.*),(.*)/;
                my ($chr_2_b, $start_2_b, $end_2_b)=($1, $2, $3);
                my ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2, $chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2);
                if($chr_breakpoint_1 eq $chr_breakpoint_2){
                    next if $chr_1_a ne $chr_1_b || $chr_2_a ne $chr_2_b || $chr_1_a ne $chr_2_a || $chr_1_a ne $chr_breakpoint_1;
                    # two segment may overlap: next if $start_1_b>=$start_1_a && $start_1_b<=$end_1_a; # two segment should not overlap
                    # two segment may overlap: next if $end_1_b>=$start_1_a && $end_1_b<=$end_1_a; # two segment should not overlap
                    # two segment may overlap: next if $start_2_b>=$start_2_a && $start_2_b<=$end_2_a; # two segment should not overlap
                    # two segment may overlap: next if $end_2_b>=$start_2_a && $end_2_b<=$end_2_a; # two segment should not overlap
                    
                    if($end_1_a<$end_1_b){
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_a, $start_1_a, $end_1_a, $chr_1_b, $start_1_b, $end_1_b);
                    }else{
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_b, $start_1_b, $end_1_b, $chr_1_a, $start_1_a, $end_1_a);
                    }
                    
                    if($end_2_a<$end_2_b){
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_a, $start_2_a, $end_2_a, $chr_2_b, $start_2_b, $end_2_b);
                    }else{
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_b, $start_2_b, $end_2_b, $chr_2_a, $start_2_a, $end_2_a);
                    }
                }else{
                    if($chr_1_a eq $chr_breakpoint_1){
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_a, $start_1_a, $end_1_a, $chr_1_b, $start_1_b, $end_1_b);
                    }else{
                        ($chr_1_breakpoint_1, $start_1_breakpoint_1, $end_1_breakpoint_1, $chr_1_breakpoint_2, $start_1_breakpoint_2, $end_1_breakpoint_2)=($chr_1_b, $start_1_b, $end_1_b, $chr_1_a, $start_1_a, $end_1_a);
                    }
                    next if $chr_1_breakpoint_1 ne $chr_breakpoint_1 || $chr_1_breakpoint_2 ne $chr_breakpoint_2;
                    
                    if($chr_2_a eq $chr_breakpoint_1){
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_a, $start_2_a, $end_2_a, $chr_2_b, $start_2_b, $end_2_b);
                    }else{
                        ($chr_2_breakpoint_1, $start_2_breakpoint_1, $end_2_breakpoint_1, $chr_2_breakpoint_2, $start_2_breakpoint_2, $end_2_breakpoint_2)=($chr_2_b, $start_2_b, $end_2_b, $chr_2_a, $start_2_a, $end_2_a);
                    }
                    next if $chr_2_breakpoint_1 ne $chr_breakpoint_1 || $chr_2_breakpoint_2 ne $chr_breakpoint_2;
                }
                ($chr_a, $chr_b)=($chr_breakpoint_1, $chr_breakpoint_2);
                $start_a=($start_1_breakpoint_1<$start_2_breakpoint_1) ? $start_1_breakpoint_1 : $start_2_breakpoint_1;
                $end_a=($end_1_breakpoint_1<$end_2_breakpoint_1) ? $end_2_breakpoint_1 : $end_1_breakpoint_1;
                next if $end_a-$start_a>$length_threshold_if_both_mate_are_split_reads; # $length_threshold_if_both_mate_are_split_reads is artifact number (200), if both reads are split reads, one segment should not longer than read length
                $start_b=($start_1_breakpoint_2<$start_2_breakpoint_2) ? $start_1_breakpoint_2 : $start_2_breakpoint_2;
                $end_b=($end_1_breakpoint_2<$end_2_breakpoint_2) ? $end_2_breakpoint_2 : $end_1_breakpoint_2;
                next if $end_b-$start_b>$length_threshold_if_both_mate_are_split_reads; # $length_threshold_if_both_mate_are_split_reads is artifact number (200), if both reads are split reads, one segment should not longer than read length
            }else{ # (@tophat_read_1==1 && @tophat_read_2==2) || (@tophat_read_1==2 && @tophat_read_2==1)
                my ($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2, $chr_mate, $start_mate, $end_mate);
                my ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2);
                if(@tophat_read_1==1){
                    $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                    ($chr_split_1, $start_split_1, $end_split_1)=($1, $2, $3);
                    $tophat_read_2[1]=~/(.*),(.*),(.*)/;
                    ($chr_split_2, $start_split_2, $end_split_2)=($1, $2, $3);
                    $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                    ($chr_mate, $start_mate, $end_mate)=($1, $2, $3);
                }else{
                    $tophat_read_1[0]=~/(.*),(.*),(.*)/;
                    ($chr_split_1, $start_split_1, $end_split_1)=($1, $2, $3);
                    $tophat_read_1[1]=~/(.*),(.*),(.*)/;
                    ($chr_split_2, $start_split_2, $end_split_2)=($1, $2, $3);
                    $tophat_read_2[0]=~/(.*),(.*),(.*)/;
                    ($chr_mate, $start_mate, $end_mate)=($1, $2, $3);
                }
                
                if($chr_breakpoint_1 eq $chr_breakpoint_2){
                    next if $chr_split_1 ne $chr_split_2 || $chr_split_1 ne $chr_mate || $chr_split_1 ne $chr_breakpoint_1;
                    if($start_split_1<$start_split_2){
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2);
                    }else{
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_2, $start_split_2, $end_split_2, $chr_split_1, $start_split_1, $end_split_1);
                    }
                        
                    my $distance_mate_to_split_breakpoint_1=abs($start_mate-$start_split_breakpoint_1);
                    my $distance_mate_to_split_breakpoint_2=abs($start_mate-$start_split_breakpoint_2);
                    ($chr_a, $chr_b)=($chr_breakpoint_1, $chr_breakpoint_2);
                    if($distance_mate_to_split_breakpoint_1<$distance_mate_to_split_breakpoint_2){
                        $start_a=($start_split_breakpoint_1<$start_mate) ? $start_split_breakpoint_1 : $start_mate;
                        $end_a=($end_split_breakpoint_1<$end_mate) ? $end_mate : $end_split_breakpoint_1;
                        ($start_b, $end_b)=($start_split_breakpoint_2, $end_split_breakpoint_2);
                    }else{
                        ($start_a, $end_a)=($start_split_breakpoint_1, $end_split_breakpoint_1);
                        $start_b=($start_split_breakpoint_2<$start_mate) ? $start_split_breakpoint_2 : $start_mate;
                        $end_b=($end_split_breakpoint_2<$end_mate) ? $end_mate : $end_split_breakpoint_2;
                    }
                }else{
                    next if $chr_breakpoint_1 ne $chr_mate && $chr_breakpoint_2 ne $chr_mate;
                    
                    if($chr_split_1 eq $chr_breakpoint_1){
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_1, $start_split_1, $end_split_1, $chr_split_2, $start_split_2, $end_split_2);
                    }else{
                        ($chr_split_breakpoint_1, $start_split_breakpoint_1, $end_split_breakpoint_1, $chr_split_breakpoint_2, $start_split_breakpoint_2, $end_split_breakpoint_2)=($chr_split_2, $start_split_2, $end_split_2, $chr_split_1, $start_split_1, $end_split_1);
                    }
                    next if $chr_split_breakpoint_1 ne $chr_breakpoint_1 || $chr_split_breakpoint_2 ne $chr_breakpoint_2;
                    
                    ($chr_a, $chr_b)=($chr_breakpoint_1, $chr_breakpoint_2);
                    if($chr_breakpoint_1 eq $chr_mate){
                        $start_a=($start_split_breakpoint_1<$start_mate) ? $start_split_breakpoint_1 : $start_mate;
                        $end_a=($end_split_breakpoint_1<$end_mate) ? $end_mate : $end_split_breakpoint_1;
                        ($start_b, $end_b)=($start_split_breakpoint_2, $end_split_breakpoint_2);
                    }else{
                        ($start_a, $end_a)=($start_split_breakpoint_1, $end_split_breakpoint_1);
                        $start_b=($start_split_breakpoint_2<$start_mate) ? $start_split_breakpoint_2 : $start_mate;
                        $end_b=($end_split_breakpoint_2<$end_mate) ? $end_mate : $end_split_breakpoint_2;
                    }
                }
                
            }
            
            # compare read to breakpoints
            my ($is_breakpoint_1_support_breakpoint, $is_breakpoint_2_support_breakpoint)=(0) x 2;
            $is_breakpoint_1_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_1, $strand_breakpoint_1, $start_a, $end_a);
            $is_breakpoint_2_support_breakpoint=&compareSplitReadToBreakpoint($pos_breakpoint_2, $strand_breakpoint_2, $start_b, $end_b);
            
            if($is_breakpoint_1_support_breakpoint==1 && $is_breakpoint_2_support_breakpoint==1){
                $split_read_count_tophat++;
                $split_reads_tophat.=",".$read;
            }
        }
    }
    
    foreach my $read (@Read_pairs){
        next if $read eq "NA";
        my (@tophat_read_1, @tophat_read_2);
        @tophat_read_1=@{$hash{$read}{"first"}} if exists $hash{$read}{"first"};
        @tophat_read_2=@{$hash{$read}{"second"}} if exists $hash{$read}{"second"};
        
        next if @tophat_read_1!=1 || @tophat_read_2!=1; # not unique aligned
        my ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b); # a: breakpoint 1 segment; b: breakpoint 2 segment;
        $tophat_read_1[0]=~/(.*),(.*),(.*)/;
        my ($chr_1, $start_1, $end_1)=($1, $2, $3);
        $tophat_read_2[0]=~/(.*),(.*),(.*)/;
        my ($chr_2, $start_2, $end_2)=($1, $2, $3);
        if($chr_breakpoint_1 eq $chr_breakpoint_2){
            next if $chr_1 ne $chr_2;
            next if $chr_1 ne $chr_breakpoint_1;
            
            if($end_1<$end_2){
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
            }else{
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1);
            }
        }else{
            if($chr_1 eq $chr_breakpoint_1){
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_1, $start_1, $end_1, $chr_2, $start_2, $end_2);
            }else{
                ($chr_a, $start_a, $end_a, $chr_b, $start_b, $end_b)=($chr_2, $start_2, $end_2, $chr_1, $start_1, $end_1);
            }
            next if $chr_a ne $chr_breakpoint_1 || $chr_b ne $chr_breakpoint_2;
        }
        
        # compare read to breakpoints
        my ($is_breakpoint_1_support_breakpoint, $is_breakpoint_2_support_breakpoint)=(0) x 2;
        my ($temp_distance_breakpoint_1, $temp_distance_breakpoint_2)=(0) x 2;
        if($strand_breakpoint_1 eq '+'){
            $is_breakpoint_1_support_breakpoint=1 if ($end_a<=$pos_breakpoint_1) && ($pos_breakpoint_1-$end_a<=$window_size);
            $temp_distance_breakpoint_1=$pos_breakpoint_1-$end_a;
        }else{
            $is_breakpoint_1_support_breakpoint=1 if ($start_a>=$pos_breakpoint_1) && ($start_a-$pos_breakpoint_1<=$window_size);
            $temp_distance_breakpoint_1=$start_a-$pos_breakpoint_1;
        }
        if($strand_breakpoint_2 eq '+'){
            $is_breakpoint_2_support_breakpoint=1 if ($end_b<=$pos_breakpoint_2) && ($pos_breakpoint_2-$end_b<=$window_size);
            $temp_distance_breakpoint_2=$pos_breakpoint_2-$end_b;
        }else{
            $is_breakpoint_2_support_breakpoint=1 if ($start_b>=$pos_breakpoint_2) && ($start_b-$pos_breakpoint_2<=$window_size);
            $temp_distance_breakpoint_2=$start_b-$pos_breakpoint_2;
        }
        
        if($is_breakpoint_1_support_breakpoint==1 && $is_breakpoint_2_support_breakpoint==1){
            $read_pair_count_tophat++;
            $read_pairs_tophat.=",".$read;
            
            $read_distance_to_breakpoint_1.=",".$temp_distance_breakpoint_1;
            $read_distance_to_breakpoint_2.=",".$temp_distance_breakpoint_2;
            if($min_read_pair_distance_breakpoint_1 eq "NA"){
                $min_read_pair_distance_breakpoint_1=$temp_distance_breakpoint_1;
            }elsif($min_read_pair_distance_breakpoint_1>$temp_distance_breakpoint_1){
                $min_read_pair_distance_breakpoint_1=$temp_distance_breakpoint_1;
            }
            if($min_read_pair_distance_breakpoint_2 eq "NA"){
                $min_read_pair_distance_breakpoint_2=$temp_distance_breakpoint_2;
            }elsif($min_read_pair_distance_breakpoint_2>$temp_distance_breakpoint_2){
                $min_read_pair_distance_breakpoint_2=$temp_distance_breakpoint_2;
            }
        }
    }
        
    $split_reads_tophat=~s/NA,//;
    $read_pairs_tophat=~s/NA,//;
    $potential_split_reads_tophat=~s/NA,//;
    $read_distance_to_breakpoint_1=~s/NA,//;
    $read_distance_to_breakpoint_2=~s/NA,//;
    
    next if ($split_read_count_tophat+$potential_split_read_count_tophat)<$min_split_reads;
    next if $read_pair_count_tophat<$min_read_pairs;
    next if ($split_read_count_tophat+$potential_split_read_count_tophat+$read_pair_count_tophat)<$min_total_reads;
    next if $min_read_pair_distance_breakpoint_1>$max_read_pair_distance || $min_read_pair_distance_breakpoint_2>$max_read_pair_distance;
    
    say join "\t", ($chr_breakpoint_1, $pos_breakpoint_1, $strand_breakpoint_1, $chr_breakpoint_2, $pos_breakpoint_2, $strand_breakpoint_2, $cluster_id,
        $split_read_count, $read_pair_count, $split_read_count_tophat, $potential_split_read_count_tophat, $read_pair_count_tophat,
        $min_read_pair_distance_breakpoint_1, $min_read_pair_distance_breakpoint_2,
        $split_reads, $read_pairs, $split_reads_tophat, $potential_split_reads_tophat, $read_pairs_tophat,
        $read_distance_to_breakpoint_1, $read_distance_to_breakpoint_2);
}
close(IN);

sub getReadIndex{
    my ($flag)=@_;
    my $segment_index;
    if($flag & 64){
        $segment_index="first";
    }else{
        $segment_index="second";
    }
    return $segment_index;
}

sub getEnd{
    my ($start, $cigar)=@_;
    my $end=$start-1; # start is 1-base, change to 0-base
    while($cigar =~ /(\d+)([A-Zp])/g) {
        my $len = $1;
        my $code = $2;
        unless($code =~ /^[MSDNIHp]$/) {
            say STDERR "Error, cannot parse cigar code [$code] ";
        }
        $end+=$len if $code eq "M" || $code eq "N" || $code eq "D";
    }
    return $end;
}

sub compareSplitReadToBreakpoint{
    my ($pos_breakpoint, $strand_breakpoint, $start_read, $end_read)=@_;
    my $is_support_breakpoint=0;
    if($strand_breakpoint eq '+'){
        $is_support_breakpoint=1 if ($end_read<=$pos_breakpoint+$overhang_length) && ($pos_breakpoint+$overhang_length-$end_read<=$window_size);
    }else{
        $is_support_breakpoint=1 if ($start_read>=$pos_breakpoint-$overhang_length) && ($start_read-$pos_breakpoint+$overhang_length<=$window_size);
    }
    return $is_support_breakpoint;
}

sub usage{
    my $scriptName = basename $0;
print <<HELP;
This script was used to get tophat supported statistics
Usage: perl $scriptName tophat.bam input >output
Options:

    -o --overhang_length                                INT     Breakpoint overhang length [default: $overhang_length]
    -w --window_size	                                   INT     Maximal distance between TopHat alignment and breakpoint [default: $window_size]
    -l --length_threshold_if_both_mate_are_split_reads  INT	    Maximal distance between alignments if both read 1 and read 2 are split reads [default: $length_threshold_if_both_mate_are_split_reads]
    -d --max_read_pair_distance	                        INT     Maximal distance between the TopHat alignment of read pairs and breakpoint [default: $max_read_pair_distance]
    -p --min_split_reads	                               INT     Minimal number of split reads for a fusion transcript to be identified [default: $min_split_reads]
    -r --min_read_pairs	                                INT     Minimal number of read pairs for a fusion transcript to be identified [default: $min_read_pairs]
    -t --min_total_reads	                               INT     Minimal number of total reads for a fusion transcript to be identified [default: $min_total_reads]
    -h --help     	                                             Print this help information
HELP
    exit(-1);
}